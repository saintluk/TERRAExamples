/**
 * Source file for the FMI_plant model
 * Generated by the TERRA CSPm2LUNA generator version 1.1.3
 *
 * FMI C++ glue code to connect to plant
 * Modifying this file is absolutely not recommended!
 *
 * protected region document description on begin
 *
 * protected region document description end
 */

#include "FMI_plant.h"
// protected region additional headers on begin
// Each additional header should get a corresponding dependency in the Makefile
#include "xxmodel.h"
// protected region additional headers end

namespace plant {
namespace FMI_plant {

FMI_plant::FMI_plant(double &control, double &height) :
		CodeBlock(), control(control), height(height) {
	SETNAME(this, "FMI_plant");

	// Create the text for the header of the measurement log
	std::string measurementNames = "Time,control,height";

	// Initialization of the log functions
	logger->initLogger("measurement_plant.csv", "log.txt", measurementNames);

	// Load shared lib
	handle = dlopen("/usr/local/lib/libSOplant.so", RTLD_LAZY);

	// Instantiation of the FMU
	f_instantiate = (fp_instantiate) dlsym(handle, "fmi2Instantiate");
	s1 = f_instantiate("plant", fmi2CoSimulation,
			"{cd2add09-a420-4273-ada0-27cd3a18ec88}", "", &cbf, fmi2True,
			fmi2False);

	if (s1 == NULL) {
		logger->fmiLog(NULL, "plant", fmi2Error, "error",
				"fmi2Instatiate is not created.");
	} else {
		logger->fmiLog(NULL, "plant", fmi2OK, "info",
				"fmi2Instatiate is created correctly.");
	}

	// Set variables for simulation
	//communication step size, not the integration step size, the minor communication step size is decided by the integration step size.
	timeStep = 0.001;
	currentTime = 0.0;
	status = fmi2OK;
	simulationFinished = false;

	//Set parameters
	fmi2ValueReference parameterRealRef[13] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
			10, 11, 12 };
	fmi2Real parameterRealVal[13] = { 1.0, 9.81, 1.0, 1.0, 9.81, 1.0, 1.0, 10.0,
			300.0, 1.0, 2.0, 0.0, 0.0 };
	fmi2SetReal(s1, parameterRealRef, 13, parameterRealVal);

	f_setup = (fp_setup) dlsym(handle, "fmi2SetupExperiment");
	f_setup(s1, fmi2False, 0.0, 0.0, fmi2True, 20.0);

	f_enterInit = (fp_enterInit) dlsym(handle, "fmi2EnterInitializationMode");
	f_enterInit(s1);

//	 f_exit = (fp_exit)dlsym(handle,"fmi2ExitInitializationMode");
//	 f_exit(s1);

	fmi2ValueReference outputRealRef[1] = { 24 };
	fmi2Real outputRealVal[1] = { 0 };
	fmi2GetReal(s1, outputRealRef, 1, outputRealVal);
	height = outputRealVal[0];
//	 printf("init height is %f\n", height);
}

FMI_plant::~FMI_plant() {
	fmi2Terminate(s1);
	fmi2FreeInstance(s1);
}

void FMI_plant::execute() {
	static long long i = 0;

	static bool rollback_flag = true;
	static bool store_state_done = false;

	if (i++ == 0) {

		fmi2ValueReference inputRealRef[1] = { 23 };
		fmi2Real inputRealVal[1] = { control };
		fmi2SetReal(s1, inputRealRef, 1, inputRealVal);


		//skip 1st iteration, to sync initial states
		//do init again in fmi2ExitInitializationMode
		f_exit = (fp_exit) dlsym(handle, "fmi2ExitInitializationMode");
		f_exit(s1);

		fmi2ValueReference outputRealRef[1] = { 24 };
		fmi2Real outputRealVal[1] = { 0 };
		fmi2GetReal(s1, outputRealRef, 1, outputRealVal);
		height = outputRealVal[0];

		//printf("init height is %f\n", height);
		clock_gettime( CLOCK_REALTIME, &start);
	} else if (rollback_flag == true) {
		//the iteration before roll back, without time advancing and logging
		if (store_state_done == false) {
			if (simulationFinished == false && status == fmi2OK) {
				fmi2ValueReference inputRealRef[1] = { 23 };
				fmi2Real inputRealVal[1] = { control };
				fmi2SetReal(s1, inputRealRef, 1, inputRealVal);

				if (currentTime < 20.0) {
					fmi2GetFMUstate(s1, &FMUState);
					//printf("FMUstate time is %f\n", ((xx_ModelInstance*) s1)->time);

					f_doStep = (fp_doStep) dlsym(handle, "fmi2DoStep");
					if (f_doStep(s1, currentTime, timeStep, fmi2True)
							!= fmi2OK) {
						//printf("FMI: Error no simulation\n");
					}

					fmi2ValueReference outputRealRef[1] = { 24 };
					fmi2Real outputRealVal[1] = { 0 };
					fmi2GetReal(s1, outputRealRef, 1, outputRealVal);
					height = outputRealVal[0];

					// Save the values of the input and output to a file
					if(currentTime > 9.999 && currentTime < 10.003)
					{
					logger->saveMeasurementPoint(
							std::to_string(currentTime) + ","
									+ std::to_string(control) + ","
									+ std::to_string(height));
					}

					store_state_done = true;
				} else {
					simulationFinished = true;
				}
			} else if (status != fmi2OK) {
				printf("FMU: The simulation is stopped because of an error\n");
				std::_Exit(0);
			} else {
				clock_gettime( CLOCK_REALTIME, &end);
				accum = (double)(end.tv_sec - start.tv_sec )
							+ (double)( end.tv_nsec - start.tv_nsec )/(double)1000000000L;
				printf("FMU: Simulation is done, time used is %f\n", accum);
				fmi2Terminate(s1);
				fmi2FreeInstance(s1);
				//exit();
				std::_Exit(0);
			}
		} else if (store_state_done == true) {

			if (simulationFinished == false && status == fmi2OK) {
				fmi2SetFMUstate(s1, FMUState);
				//printf("Restored time is %f\n", ((xx_ModelInstance*) s1)->time);

				fmi2ValueReference inputRealRef[1] = { 23 };
				fmi2Real inputRealVal[1] = { control };
				fmi2SetReal(s1, inputRealRef, 1, inputRealVal);

				if (currentTime < 20.0) {
					f_doStep = (fp_doStep) dlsym(handle, "fmi2DoStep");
					if (f_doStep(s1, currentTime, timeStep, fmi2True)
							!= fmi2OK) {
						//printf("FMI: Error no simulation\n");
					}

					fmi2ValueReference outputRealRef[1] = { 24 };
					fmi2Real outputRealVal[1] = { 0 };
					fmi2GetReal(s1, outputRealRef, 1, outputRealVal);
					height = outputRealVal[0];

					// Save the values of the input and output to a file
					logger->saveMeasurementPoint(
							std::to_string(currentTime) + ","
									+ std::to_string(control) + ","
									+ std::to_string(height));

					currentTime = currentTime + timeStep;
					store_state_done = false;
				} else {
					simulationFinished = true;
				}
			} else if (status != fmi2OK) {
				printf("FMU: The simulation is stopped because of an error\n");
				std::_Exit(0);
			} else {
				printf("FMU: Simulation is done\n");
				fmi2Terminate(s1);
				fmi2FreeInstance(s1);
				std::_Exit(0);
			}
		}
	}
	//without roll back mechanism
	else if (rollback_flag == false) {
		if (simulationFinished == false && status == fmi2OK) {
			fmi2ValueReference inputRealRef[1] = { 23 };
			fmi2Real inputRealVal[1] = { control };
			fmi2SetReal(s1, inputRealRef, 1, inputRealVal);

			if (currentTime < 20.0) {
				f_doStep = (fp_doStep) dlsym(handle, "fmi2DoStep");
				if (f_doStep(s1, currentTime, timeStep, fmi2True) != fmi2OK) {
					printf("FMI: Error no simulation\n");
				}

				fmi2ValueReference outputRealRef[1] = { 24 };
				fmi2Real outputRealVal[1] = { 0 };
				fmi2GetReal(s1, outputRealRef, 1, outputRealVal);
				height = outputRealVal[0];

				// Save the values of the input and output to a file
				logger->saveMeasurementPoint(
						std::to_string(currentTime) + ","
								+ std::to_string(control) + ","
								+ std::to_string(height));

				currentTime = currentTime + timeStep;

			} else {
				simulationFinished = true;
			}
		} else if (status != fmi2OK) {
			printf("FMU: The simulation is stopped because of an error\n");
			std::_Exit(0);
		} else {
			clock_gettime( CLOCK_REALTIME, &end);
			accum = (double)(end.tv_sec - start.tv_sec )
						+ (double)( end.tv_nsec - start.tv_nsec )/(double)1000000000L;
			printf("FMU: Simulation is done, time used is %f\n", accum);
			fmi2Terminate(s1);
			fmi2FreeInstance(s1);
			std::_Exit(0);
		}
	}
}

// protected region additional functions on begin
// protected region additional functions end

// Close namespace(s)
}
}
